 configure.ac                           |    3 ++-
 src/libinstrudeo/isdffmpegexporter.cpp |   17 +++++++++++------
 src/libinstrudeo/isdffmpegexporter.h   |    7 +++++--
 3 files changed, 18 insertions(+), 9 deletions(-)

diff --git a/configure.ac b/configure.ac
index 2549623..002f4f4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -92,6 +92,7 @@ AC_CHECK_LIB([vorbisenc], [vorbis_encode_init], , AC_MSG_ERROR([*** vorbisenc mi
 AC_CHECK_LIB([theora], [theora_info_init], , AC_MSG_ERROR([*** theora missing - please install libtheora development package ***]))
 AC_CHECK_LIB([avcodec], [avcodec_init], , AC_MSG_ERROR([*** avcodec missing - please install avcodec development package ***]), [-lavutil])
 AC_CHECK_LIB([avformat], [av_open_input_stream], , AC_MSG_ERROR([*** avformat missing - please install avformat development package ***]), [-lavutil])
+AC_CHECK_LIB([swscale], [sws_scale], , AC_MSG_ERROR([*** swscale missing - please install swscale development package ***]), [-lswscale])
 dnl This should pass, since we successfully linked in the two previous checks
 dnl This step add the necessary -lavutil to the LIBS variable
 dnl Note: specifying a method caused troubles, so I switched to main
@@ -144,4 +145,4 @@ AC_FUNC_STRTOD
 AC_CHECK_FUNCS([ftime gethostbyname gettimeofday localtime_r memset munmap select setlocale socket sqrt strchr strdup strerror strrchr strstr strtoull])
 
 AC_CONFIG_FILES(Makefile src/Makefile src/libinstrudeo/webservice/Makefile src/libinstrudeo/Makefile src/isdexport/Makefile data/Makefile data/commentboxes/Makefile data/fonts/Makefile)
-AC_OUTPUT
\ No newline at end of file
+AC_OUTPUT
diff --git a/src/libinstrudeo/isdffmpegexporter.cpp b/src/libinstrudeo/isdffmpegexporter.cpp
index 3bf38f5..62836c2 100644
--- a/src/libinstrudeo/isdffmpegexporter.cpp
+++ b/src/libinstrudeo/isdffmpegexporter.cpp
@@ -79,6 +79,7 @@ ISDFFmpegExporter::~ISDFFmpegExporter()
 ISDObject::ISDErrorCode ISDFFmpegExporter::doExport(char* pixelBuffer)
 {
     char* grabBuffer;
+    struct SwsContext *toYUV_convert_ctx;
     
     if (!initOK) {
 	LOG_WARNING("Export routine called without initializing the encoder.");
@@ -95,6 +96,9 @@ ISDObject::ISDErrorCode ISDFFmpegExporter::doExport(char* pixelBuffer)
 	int bufSize = videoProperties->getHeight()*videoProperties->getWidth()*videoProperties->getBytesPerPixel();
 	grabBuffer = (char*)malloc(bufSize);
     }
+    toYUV_convert_ctx = sws_getContext(codecContext->width, codecContext->height, inputPixFmt,
+                    outputContext->streams[0]->codec->width, outputContext->streams[0]->codec->height,
+                    FFMPEG_STREAM_PIX_FMT, SWS_BICUBIC, NULL, NULL, NULL);
 
     /*
      * Note: video time is in milliseconds, so if we have a framerate
@@ -126,12 +130,13 @@ ISDObject::ISDErrorCode ISDFFmpegExporter::doExport(char* pixelBuffer)
 	}
 	    
 	//convert input pic to yuv420p
-	if (img_convert(&yuvInputPicture, FFMPEG_STREAM_PIX_FMT, &inputPicture, 
-			inputPixFmt, codecContext->width, codecContext->height) < 0)
-	    {
-		LOG_WARNING("Pixel format conversion not handled while exporting.");
-		RETURN_ERROR(ISD_EXPORT_FORMAT_ERROR);
-	    }
+        if (sws_scale(toYUV_convert_ctx, inputPicture.data, inputPicture.linesize, 0, codecContext->height,
+                        yuvInputPicture.data, yuvInputPicture.linesize) < 0)
+            {
+                LOG_WARNING("Pixel format conversion not handled while exporting.");
+                RETURN_ERROR(ISD_EXPORT_FORMAT_ERROR);
+            }
+
 	    
 	outSize = avcodec_encode_video(codecContext, outputBuf, outputBufSize, inputFrame);
 	//if zero size, it means the image was buffered
diff --git a/src/libinstrudeo/isdffmpegexporter.h b/src/libinstrudeo/isdffmpegexporter.h
index 06082ec..b69f317 100644
--- a/src/libinstrudeo/isdffmpegexporter.h
+++ b/src/libinstrudeo/isdffmpegexporter.h
@@ -47,8 +47,11 @@
 
 #include <libinstrudeo/isdexporter.h>
 
-#include <ffmpeg/avcodec.h>
-#include <ffmpeg/avformat.h>
+extern "C" {
+#include <libavcodec/avcodec.h>
+#include <libavformat/avformat.h>
+#include <libswscale/swscale.h>
+}
 
 using namespace std;
 
